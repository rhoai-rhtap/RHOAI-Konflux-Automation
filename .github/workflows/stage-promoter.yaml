name: Stage Promoter
run-name: Stage Promoter
on:
  workflow_dispatch:
    inputs:
      release_branch:
        description: 'Release Branch'
        required: true
      rhoai_version:
        description: 'Current RHOAI version, eg v2.14.0'
        required: true
      fbc_image_uri:
        description: 'Full image uri of the FBC fragment image'
        default: 'LATEST_NIGHTLY'
      force_build:
        type: choice
        description: Force trigger all the builds again
        default: No
        options:
          - No
          - Yes
      build_type:
        type: choice
        description: type of the build, nightly/RC
        default: Nightly
        options:
          - Nightly
          - RC

permissions:
  contents: write
env:
  GITHUB_ORG: red-hat-data-services
  GITHUB_RKA_ORG: rhoai-rhtap
  SLACK_FAILURE_MESSAGE: ""
  MAX_RETRY_COUNT: 3
  ARTIFACTS_NAME: stage-release-artifacts

jobs:
  push-to-stage:
    if: ${{ github.ref_name == 'main' }}
    runs-on:
      - konflux
      - stage
    container:
      image: quay.io/rhoai/rhoai-task-toolset:stage
    steps:
      - name: Init
        id: init
        env:
          OC_TOKEN: ${{ secrets.RHOAI_KONFLUX_INTERNAL_SA_TOKEN }}
          API_SERVER: ${{ secrets.KONFLUX_INTERNAL_API_SERVER_URL }}
          BRANCH: ${{ github.event.inputs.release_branch }}
        run: |
          abs_cwd=$(pwd)
          work_dir=stage-$(date +%s)
          mkdir $work_dir
          cd $work_dir
          pwd
          mkdir -p artifacts/component-release
          mkdir -p artifacts/fbc-build
          mkdir -p artifacts/fbc-release
          
          echo "work_dir=$work_dir"
          echo "work_dir=$work_dir" >> $GITHUB_OUTPUT
          echo "abs_cwd=$abs_cwd" >> $GITHUB_OUTPUT
          
          oc login --token="${OC_TOKEN}" --server=${API_SERVER}
          oc config set-context --current --namespace=rhoai-tenant
          
          SLACK_FAILURE_MESSAGE=":alert:${{ github.event.inputs.build_type }} stage push failed for *${BRANCH}*. \n Please check the logs at ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          #  \nCC - <!subteam^S05B904NQ6L|openshift-ai-devops>
          echo "SLACK_FAILURE_MESSAGE=${SLACK_FAILURE_MESSAGE}" >> ${GITHUB_ENV}

      - name: Generate github-app token
        id: app-token
        run: |
          echo "token=${{ secrets.RBC_TOKEN }}" >> $GITHUB_OUTPUT
#        uses: getsentry/action-github-app-token@v2
#        with:
#          app_id: ${{ secrets.DEVOPS_APP_ID }}
#          private_key: ${{ secrets.DEVOPS_APP_PRIVATE_KEY }}
      - name: Git checkout CFR
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.release_branch }}
          path: ${{ steps.init.outputs.work_dir }}/cfr
          repository: ${{ env.GITHUB_ORG }}/conforma-reporter
          token: ${{ secrets.RBC_TOKEN }}
      - name: Git checkout DevOps Infra
        uses: actions/checkout@v4
        with:
          ref: main
          path: ${{ steps.init.outputs.work_dir }}/infra
          sparse-checkout: |
            tools/rhoai-release-helper
          sparse-checkout-cone-mode: false
      - name: Git checkout RBC main
        uses: actions/checkout@v4
        with:
          ref: main
          path: ${{ steps.init.outputs.work_dir }}/main
          repository: ${{ env.GITHUB_ORG }}/RHOAI-Build-Config
          token: ${{ secrets.RBC_TOKEN }}
          sparse-checkout: |
            pcc
            catalog/${{ github.event.inputs.release_branch }}
            builds
          sparse-checkout-cone-mode: false
      - name: Git checkout RBC Release Latest
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.release_branch }}
          repository: ${{ env.GITHUB_ORG }}/RHOAI-Build-Config
          path: ${{ steps.init.outputs.work_dir }}/latest_rbc_release
          sparse-checkout: |
            config/build-config.yaml
          sparse-checkout-cone-mode: false
      - name: Validate FBC Image
        id: validate-fbc-image
        run: |
          BASE_URI=docker://quay.io/rhoai/rhoai-fbc-fragment
          release_branch=${{ github.event.inputs.release_branch }}
          image_uri=${{ github.event.inputs.fbc_image_uri }}
          if [[ $image_uri == LATEST_NIGHTLY ]]; then image_uri=${BASE_URI}:${release_branch}-nightly; fi
          if [[ "$image_uri" != docker* ]]; then image_uri="docker://${image_uri}"; fi

          META=$(skopeo inspect "${image_uri}")
          DIGEST=$(echo $META | jq -r .Digest)
          image_uri=${BASE_URI}@${DIGEST}
          GIT_COMMIT=$(echo $META | jq -r '.Labels | ."git.commit"')
          SIG_TAG=${DIGEST/:/-}.sig
          SIG_DIGEST=$(skopeo inspect ${BASE_URI}:${SIG_TAG}  | jq -r .Digest)
          
          if [[ -z $SIG_DIGEST ]]
          then
            echo "Invalid FBC image, no valid signatures found, exiting.."
            SLACK_FAILURE_MESSAGE=":alert:${{ github.event.inputs.build_type }} stage push failed for *${release_branch}* while validating the FBC image ${image_uri}. \n Please check the logs at ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
            {
              echo "SLACK_FAILURE_MESSAGE<<EOF"
              echo -e "${SLACK_FAILURE_MESSAGE}"
              echo "EOF"
            } >> $GITHUB_ENV
            exit 1
          fi
          echo "Valid signature found with the digest - ${SIG_DIGEST}"
          echo "Validation successful, preparing to push the image to stage - ${image_uri}"

          ref=${DIGEST}
          echo "ref=${GIT_COMMIT}" >> $GITHUB_OUTPUT
          echo "digest=${DIGEST}" >> $GITHUB_OUTPUT
          echo "image_uri=${image_uri}" >> $GITHUB_OUTPUT
          echo "ref=$ref"
      - name: Git checkout RBC release commit
        uses: actions/checkout@v4
        with:
          ref: ${{ steps.validate-fbc-image.outputs.ref }}
          path: ${{ steps.init.outputs.work_dir }}/${{ github.event.inputs.release_branch }}
          repository: ${{ env.GITHUB_ORG }}/RHOAI-Build-Config
      - name: Git checkout utils
        uses: actions/checkout@v4
        with:
          repository: ${{ env.GITHUB_RKA_ORG }}/RHOAI-Konflux-Automation
          ref: stage
          path: ${{ steps.init.outputs.work_dir }}/utils
      - name: Install dependencies
        env:
          RHOAI_QUAY_RO_USERNAME: ${{ secrets.RHOAI_QUAY_RO_USERNAME }}
          RHOAI_QUAY_RO_TOKEN: ${{ secrets.RHOAI_QUAY_RO_TOKEN }}
        run: |
          cd ${{ steps.init.outputs.work_dir }}
          os="$(uname -s | tr '[:upper:]' '[:lower:]')"
          arch="$(uname -m | sed 's/x86_64/amd64/')"
          yq_version="v4.44.3"
          yq_filename="yq-$yq_version"
          echo "-> Downloading yq" >&2
          curl -sSfLo "$yq_filename" "https://github.com/mikefarah/yq/releases/download/$yq_version/yq_${os}_${arch}"
          chmod +x $yq_filename
          ln -s $yq_filename yq
          cp $yq_filename /usr/local/bin/yq

          # microdnf install -y skopeo && \
          #    microdnf clean all && rm -rf /var/cache/dnf/*
          skopeo login -u "${RHOAI_QUAY_RO_USERNAME}" -p "${RHOAI_QUAY_RO_TOKEN}" quay.io/rhoai

          pip install --default-timeout=100 -r infra/tools/rhoai-release-helper/requirements.txt
          pip install -r utils/utils/bundle-processor/requirements.txt
          pip install -r utils/utils/stage-promoter/requirements.txt

      - name: Check if all the prerequisites are green
        run: |
          cd ${{ steps.init.outputs.work_dir }}
          CONFORMA_RESULTS_FILE_PATH=cfr/conforma_overall_status.yaml
          SMOKES_RESULTS_FILE_PATH=cfr/smoke_overall_status.yaml
          
          python3 utils/utils/stage-promoter/stage_promoter.py -op check-prerequisite-status --rhoai-version ${BRANCH} --build-type ${{ github.event.inputs.build_type }} --conforma-results-file-path "${CONFORMA_RESULTS_FILE_PATH}" --smokes-results-file-path "${SMOKES_RESULTS_FILE_PATH}"

          if [[ -e "utils/slack_failure_message.txt" ]]
          then
            echo "Exiting.."
            SLACK_FAILURE_MESSAGE=$(cat utils/slack_failure_message.txt)
            echo ${SLACK_FAILURE_MESSAGE}
            {
              echo "SLACK_FAILURE_MESSAGE<<EOF"
              echo -e "${SLACK_MESSAGE}"
              echo "EOF"
            } >> $GITHUB_ENV
            exit 1
          fi












      - name: Release Components to Stage
        id: release-components-to-stage
        env:
          OC_TOKEN: ${{ secrets.RHOAI_KONFLUX_INTERNAL_SA_TOKEN }}
          API_SERVER: ${{ secrets.KONFLUX_INTERNAL_API_SERVER_URL }}
          QUAY_DEVOPS_APPLICATION_TOKEN: ${{ secrets.QUAY_DEVOPS_APPLICATION_TOKEN }}
        run: |
          release_branch=${{ github.event.inputs.release_branch }}
          input_rhoai_version=${{ github.event.inputs.rhoai_version }}
          fbc_image_uri=${{ github.event.inputs.fbc_image_uri }}
          rhoai_version=${input_rhoai_version/v/}
          hyphenized_rhoai_version=${release_branch/rhoai-/}
          hyphenized_rhoai_version=v${hyphenized_rhoai_version/./-}
          component_application=rhoai-${hyphenized_rhoai_version}

          oc login --token="${OC_TOKEN}" --server=${API_SERVER}
          oc config set-context --current --namespace=rhoai-tenant
          oc get snapshots | wc -l
          cd ${{ steps.init.outputs.work_dir }}/infra/tools/rhoai-release-helper
          chmod +x *.sh
          sed -i "s/release_branch=rhoai-.*/release_branch=${release_branch}/g" release-components-to-stage.sh
          sed -i "s/^rhoai_version=.*/rhoai_version=${rhoai_version}/g" release-components-to-stage.sh
          sed -i "s/hyphenized_rhoai_version=v.*/hyphenized_rhoai_version=${hyphenized_rhoai_version}/g" release-components-to-stage.sh
          sed -i "s/hyphenized_rhoai_version=v.*/hyphenized_rhoai_version=${hyphenized_rhoai_version}/g" release-components-to-stage.sh
          epoch=$(date +%s)
          # Trigger the components release pipeline
          RHOAI_QUAY_API_TOKEN="${QUAY_DEVOPS_APPLICATION_TOKEN}" epoch=${epoch} image_uri="${fbc_image_uri}" execution_env=gha build_type="${{ github.event.inputs.build_type }}" ./release-components-to-stage.sh

          release_artifacts_dir=$(ls | grep stage-release-)
          echo "ARTIFACTS_NAME=${release_artifacts_dir}" >> ${GITHUB_ENV}
          echo "epoch=${epoch}" >> ${GITHUB_OUTPUT}
          echo "component_application=${component_application}" >> ${GITHUB_OUTPUT}
          echo "snapshot_name=${component_application}-${epoch}" >> ${GITHUB_OUTPUT}


      - name: Monitor the component release pipeline
        id: monitor-component-release-pipeline
        env:
          OC_TOKEN: ${{ secrets.RHOAI_KONFLUX_INTERNAL_SA_TOKEN }}
          API_SERVER: ${{ secrets.KONFLUX_INTERNAL_API_SERVER_URL }}
        run: |
          cd ${{ steps.init.outputs.work_dir }}
          sleep 30
          snapshot_name=${{ steps.release-components-to-stage.outputs.snapshot_name }}
          application_name=${{ steps.release-components-to-stage.outputs.component_application }}
          echo "snapshot_name=$snapshot_name"
          echo "application_name=$application_name"
          pipelinerun_name=$(oc get pr -o json -n rhtap-releng-tenant -l appstudio.openshift.io/snapshot=${snapshot_name} | jq -r "[.items | sort_by(.metadata.creationTimestamp) | reverse | .[] | .metadata.name][0]")

          echo "Monitoring the pipelinerun ${pipelinerun_name}"
          status=$(oc get pipelinerun -n rhtap-releng-tenant ${pipelinerun_name} --no-headers | awk '{print $3}')
          BASE_URI="https://konflux-ui.apps.stone-prod-p02.hjvn.p1.openshiftapps.com/ns/rhtap-releng-tenant/applications"
          pipeline_url="${BASE_URI}/${application_name}/pipelineruns/${pipelinerun_name}"
          epoch=${{ steps.release-components-to-stage.outputs.epoch }}
          FAILED_PIPELINES_INFO_PATH="artifacts/component-release/failed_build_pipelines.yaml"
          RERUN_NEEDED=false

          PR_YAML_PATH="artifacts/component-release/${pipelinerun_name}.yaml"
          oc get pr -n rhtap-releng-tenant ${pipelinerun_name} -o yaml > ${PR_YAML_PATH}

          while [[ $status == Running ]] || [[ $status == ResolvingTaskRef ]]
          do
            echo "Component release pipeline ${pipelinerun_name} is executing with status $status.."
            sleep 15
            status=$(oc get pipelinerun -n rhtap-releng-tenant ${pipelinerun_name} --no-headers | awk '{print $3}')
          done



          if [[ $status == Succeeded ]] || [[ $status == Completed ]]
          then
            echo "The component release pipeline ${pipelinerun_name} successfully completed with status $status"
          else
            echo The component release pipeline ${pipelinerun_name} exited with status $status..please check the pipeline logs at ${pipeline_url}
            RERUN_NEEDED=true
            echo "${pipelinerun_name}" > ${FAILED_PIPELINES_INFO_PATH}

            echo "COMPONENT_RELEASE_RERUN_NEEDED=${RERUN_NEEDED}" >> $GITHUB_OUTPUT
            echo "FAILED_COMPONENT_RELEASE_PIPELINES_INFO_PATH=${FAILED_PIPELINES_INFO_PATH}" >> $GITHUB_OUTPUT
          fi

      - name: Retry and Monitor the component release pipeline
        if: ${{ steps.monitor-component-release-pipeline.outputs.COMPONENT_RELEASE_RERUN_NEEDED == 'true' }}
        id: retry-monitor-component-release-pipeline
        env:
          OC_TOKEN: ${{ secrets.RHOAI_KONFLUX_INTERNAL_SA_TOKEN }}
          API_SERVER: ${{ secrets.KONFLUX_INTERNAL_API_SERVER_URL }}
          BRANCH: ${{ github.event.inputs.release_branch }}
          RHOAI_VERSION: ${{ github.event.inputs.rhoai_version }}
        run: |
          cd ${{ steps.init.outputs.work_dir }}
          release_artifacts_dir=$(ls infra/tools/rhoai-release-helper/ | grep stage-release-)
          release_components_dir=infra/tools/rhoai-release-helper/${release_artifacts_dir}/release-components

          CURRENT_ITERATION=0
          FAILED_PIPELINES_INFO_PATH=${{ steps.monitor-component-release-pipeline.outputs.FAILED_COMPONENT_RELEASE_PIPELINES_INFO_PATH }}
          epoch=${{ steps.release-components-to-stage.outputs.epoch }}

          snapshot_name=${{ steps.release-components-to-stage.outputs.snapshot_name }}
          application_name=${{ steps.release-components-to-stage.outputs.component_application }}
          echo "snapshot_name=$snapshot_name"
          echo "application_name=$application_name"

          until [[ ${CURRENT_ITERATION} -eq ${MAX_RETRY_COUNT} ]]
          do
            CURRENT_ITERATION=$((CURRENT_ITERATION+1))
            if [[ -e ${FAILED_PIPELINES_INFO_PATH} ]]
            then
              echo "Following pipelines have failed, will attempt a rerun: $(cat ${FAILED_PIPELINES_INFO_PATH})"
              FAILED_PIPELINE=$(cat ${FAILED_PIPELINES_INFO_PATH})
              rm -rf ${FAILED_PIPELINES_INFO_PATH}

              echo "starting to rerun the failed pipeline ${FAILED_PIPELINE}"
              PR_YAML_PATH="artifacts/component-release/${FAILED_PIPELINE}.yaml"

              # devise yaml paths
              hyphenized_rhoai_version=${BRANCH/rhoai-/}
              hyphenized_rhoai_version=v${hyphenized_rhoai_version/./-}
              RELEASE_YAML_PATH=${release_components_dir}/release-components-stage-rhoai-${hyphenized_rhoai_version}-${epoch}.yaml
              echo "RELEASE_YAML_PATH=${RELEASE_YAML_PATH}"

              #modify the release name to retrigger
              CURRENT_RELEASE=$(yq e '.metadata.name' ${RELEASE_YAML_PATH})
              echo "CURRENT_RELEASE=${CURRENT_RELEASE}"
              NEW_RELEASE_NAME="${CURRENT_RELEASE}-${CURRENT_ITERATION}"
              NEW_RELEASE_NAME="$NEW_RELEASE_NAME" yq eval -i '.metadata.name = env(NEW_RELEASE_NAME)' ${RELEASE_YAML_PATH}

              #start the release
              echo "Starting the new component release pipeline"
              oc apply -f ${RELEASE_YAML_PATH}
              sleep 30

              # find the new pipelinerun
              pipelinerun_name=$(oc get pr -o json -n rhtap-releng-tenant -l appstudio.openshift.io/snapshot=${snapshot_name} | jq -r "[.items | sort_by(.metadata.creationTimestamp) | reverse | .[] | .metadata.name][0]")
              echo "Monitoring the pipelinerun ${pipelinerun_name}"
              BASE_URI="https://konflux-ui.apps.stone-prod-p02.hjvn.p1.openshiftapps.com/ns/rhtap-releng-tenant/applications"
              pipeline_url="${BASE_URI}/${application_name}/pipelineruns/${pipelinerun_name}"

              # store the pipeline yaml
              PR_YAML_PATH="artifacts/component-release/${pipelinerun_name}.yaml"
              oc get pr -n rhtap-releng-tenant ${pipelinerun_name} -o yaml > ${PR_YAML_PATH}

              # monitor the FBC release pipelines
              status=$(oc get pipelinerun -n rhtap-releng-tenant ${pipelinerun_name} --no-headers | awk '{print $3}')
              while [[ $status == Running ]] || [[ $status == ResolvingTaskRef ]]
              do
                echo "Component release pipeline ${pipelinerun_name} is executing with status $status.."
                sleep 15
                status=$(oc get pipelinerun -n rhtap-releng-tenant ${pipelinerun_name} --no-headers | awk '{print $3}')
              done

              if [[ $status == Succeeded ]] || [[ $status == Completed ]]
              then
                echo "The component release pipeline ${pipelinerun_name} successfully completed with status $status"
              else
                echo The component release pipeline ${pipelinerun_name} exited with status $status..please check the pipeline logs at ${pipeline_url}
                echo "${pipelinerun_name}" > ${FAILED_PIPELINES_INFO_PATH}
              fi

            fi
          done
          
          if [[ -e ${FAILED_PIPELINES_INFO_PATH} ]]
          then
            SLACK_MESSAGE="${{ github.event.inputs.build_type }} stage push failed due to the component release pipeline exited with status $status even after ${MAX_RETRY_COUNT} retry attempts. \nPlease check the Konflux logs at <${pipeline_url}|${pipelinerun_name}>"
            echo ${SLACK_MESSAGE}
            {
              echo "SLACK_FAILURE_MESSAGE<<EOF"
              echo -e "${SLACK_MESSAGE}"
              echo "EOF"
            } >> $GITHUB_ENV
            exit 1
          fi



      - name: Check if PCC Cache Valid
        id: check-if-pcc-cache-valid
        env:
          RHOAI_CATALOG_SA_USERNAME: ${{ secrets.RHOAI_CATALOG_SA_USERNAME }}
          RHOAI_CATALOG_SA_TOKEN: ${{ secrets.RHOAI_CATALOG_SA_TOKEN }}
        run: |
          cd ${{ steps.init.outputs.work_dir }}
          microdnf install -y coreutils-single && \
              microdnf clean all && rm -rf /var/cache/dnf/*
          PCC_CACHE_VALID=YES
          skopeo login registry.redhat.io -u "${RHOAI_CATALOG_SA_USERNAME}" -p "${RHOAI_CATALOG_SA_TOKEN}"
          skopeo list-tags docker://registry.redhat.io/rhoai/odh-operator-bundle | jq -r '.Tags | .[] | select(. | startswith ("v"))' | sort > latest_shipped_rhoai_versions.txt
          echo "latest_shipped_rhoai_versions = "
          cat latest_shipped_rhoai_versions.txt
          echo "shipped_rhoai_versions = "
          cat main/pcc/shipped_rhoai_versions.txt

          #diff=$(cmp --silent latest_shipped_rhoai_versions.txt main/pcc/shipped_rhoai_versions.txt || echo "files are different")
          diff=$(python -c 'print(list(set(open("latest_shipped_rhoai_versions.txt").readlines()) - set(open("main/pcc/shipped_rhoai_versions.txt").readlines())).__len__())')

          if [[ $diff -gt 0 ]]
          then
            diff=$(python -c 'print(list(set(open("latest_shipped_rhoai_versions.txt").readlines()) - set(open("main/pcc/shipped_rhoai_versions.txt").readlines())))')
            echo "following new versions are shipped - $diff"
            cp latest_shipped_rhoai_versions.txt main/pcc/shipped_rhoai_versions.txt
            PCC_CACHE_VALID=NO
          fi
          echo "PCC_CACHE_VALID=${PCC_CACHE_VALID}" >> $GITHUB_OUTPUT
      - name: Regenerate PCC Cache
        id: regenerate-pcc-cache
        if: ${{ steps.check-if-pcc-cache-valid.outputs.PCC_CACHE_VALID == 'NO' }}
        env:
          BRANCH: ${{ github.event.inputs.release_branch }}
          RHOAI_VERSION: ${{ github.event.inputs.rhoai_version }}
        run: |
          cd ${{ steps.init.outputs.work_dir }}
          #install opm cli
          os="$(uname -s | tr '[:upper:]' '[:lower:]')"
          arch="$(uname -m | sed 's/x86_64/amd64/')"
          opm_version="v1.47.0"
          opm_filename="opm-$opm_version"
          echo "-> Downloading opm" >&2
          curl -sSfLo "$opm_filename" "https://github.com/operator-framework/operator-registry/releases/download/$opm_version/$os-$arch-opm"
          chmod +x "$opm_filename"
          ln -fs "$opm_filename" opm
          cp "$opm_filename" /usr/local/bin/opm

          microdnf install -y findutils && \
              microdnf clean all && rm -rf /var/cache/dnf/*

          #Declare basic variables
          COMPONENT_SUFFIX=${RHOAI_VERSION/./-}
          OPERATOR_BUNDLE_COMPONENT_NAME=odh-operator-bundle

          #Declare FBC processing variables
          BUILD_CONFIG_PATH=${BRANCH}/config/build-config.yaml
          PATCH_YAML_PATH=${BRANCH}/catalog/catalog-patch.yaml

          CATALOG_GENERATION_REF_OCP_VERSION=v4.17
          CSV_META_MIN_OCP_VERSION=417
          BUNDLE_OBJECT_CATALOG_YAML_PATH=main/pcc/bundle_object_catalog.yaml
          CSV_META_CATALOG_YAML_PATH=main/pcc/csv_meta_catalog.yaml

          opm migrate registry.redhat.io/redhat/redhat-operator-index:${CATALOG_GENERATION_REF_OCP_VERSION} ./catalog-migrate
          opm alpha convert-template basic catalog-migrate/rhods-operator/catalog.json -o yaml > catalog-template.yaml
          opm alpha render-template basic catalog-template.yaml -o yaml > ${BUNDLE_OBJECT_CATALOG_YAML_PATH}
          opm alpha render-template basic catalog-template.yaml --migrate-level=bundle-object-to-csv-metadata -o yaml > ${CSV_META_CATALOG_YAML_PATH}

          #while IFS= read -r value;
          #do
          #    OPENSHIFT_VERSION=$value
          #    NUMERIC_OCP_VERSION=${OPENSHIFT_VERSION/v4./4}
          #    echo "OPENSHIFT_VERSION=$OPENSHIFT_VERSION"
          #
          #    CATALOG_YAML_PATH=${BUNDLE_OBJECT_CATALOG_YAML_PATH}
          #    CATALOG_DIR=main/pcc/${OPENSHIFT_VERSION}/rhods-operator
          #    mkdir -p ${CATALOG_DIR}
          #
          #    if [[ $NUMERIC_OCP_VERSION -ge $CSV_META_MIN_OCP_VERSION ]]
          #    then
          #      CATALOG_YAML_PATH=${CSV_META_CATALOG_YAML_PATH}
          #    fi
          #    cp ${CATALOG_YAML_PATH} ${CATALOG_DIR}/catalog.yaml
          #done < <(find main/pcc/ -maxdepth 1 -mindepth 1 -type d -printf '%f\n')

          ls -l main/pcc/

      - name: Validate PCC Cache
        id: validate-pcc-cache
        if: ${{ steps.check-if-pcc-cache-valid.outputs.PCC_CACHE_VALID == 'NO' }}
        env:
          BRANCH: ${{ github.event.inputs.release_branch }}
        run: |
          cd ${{ steps.init.outputs.work_dir }}
          #Declare basic variables
          BUILD_CONFIG_PATH=${BRANCH}/config/build-config.yaml
          SHIPPED_RHOAI_VERSIONS_PATH=main/pcc/shipped_rhoai_versions.txt
          PCC_FOLDER_PATH=main/pcc

          #Validate PCC
          python3 utils/utils/validators/catalog_validator.py -op validate-pcc --build-config-path ${BUILD_CONFIG_PATH} --catalog-folder-path ${PCC_FOLDER_PATH} --shipped-rhoai-versions-path ${SHIPPED_RHOAI_VERSIONS_PATH}

      - name: Push latest PCC Cache
        if: ${{ steps.check-if-pcc-cache-valid.outputs.PCC_CACHE_VALID == 'NO' }}
        uses: actions-js/push@master
        with:
          github_token: ${{ secrets.RBC_TOKEN }}
          branch: main
          message: "Regeneratd the PCC Cache"
          repository: ${{ env.GITHUB_ORG }}/RHOAI-Build-Config
          directory: ${{ steps.init.outputs.work_dir }}/main
          author_name: Openshift-AI DevOps
          author_email: openshift-ai-devops@redhat.com


      - name: Trigger Stage FBC Builds
        id: push-to-stage
        env:
          BRANCH: ${{ github.event.inputs.release_branch }}
          RHOAI_VERSION: ${{ github.event.inputs.rhoai_version }}
          COMMIT: ${{ github.event.inputs.commit }}
        run: |
          cd ${{ steps.init.outputs.work_dir }}

          #Declare basic variables
          COMPONENT_SUFFIX=${RHOAI_VERSION/./-}
          OPERATOR_BUNDLE_COMPONENT_NAME=odh-operator-bundle

          #Declare FBC processing variables
          BUILD_CONFIG_PATH=${BRANCH}/config/build-config.yaml
          PATCH_YAML_PATH=${BRANCH}/catalog/catalog-patch.yaml

          PCC_BUNDLE_OBJECT_CATALOG_YAML_PATH=main/pcc/bundle_object_catalog.yaml
          PCC_CSV_META_CATALOG_YAML_PATH=main/pcc/csv_meta_catalog.yaml
          CSV_META_MIN_OCP_VERSION=417


          while IFS= read -r ocp_version;
          do
              OPENSHIFT_VERSION=$ocp_version
              echo "OPENSHIFT_VERSION=$OPENSHIFT_VERSION"
              NUMERIC_OCP_VERSION=${OPENSHIFT_VERSION/v4./4}

              CATALOG_YAML_PATH=${PCC_BUNDLE_OBJECT_CATALOG_YAML_PATH}
              if [[ $NUMERIC_OCP_VERSION -ge $CSV_META_MIN_OCP_VERSION ]]
              then
                CATALOG_YAML_PATH=${PCC_CSV_META_CATALOG_YAML_PATH}
              fi

              RELEASE_CATALOG_YAML_PATH=${BRANCH}/catalog/${OPENSHIFT_VERSION}/rhods-operator/catalog.yaml
              OUTPUT_CATALOG_DIR=main/catalog/${BRANCH}/${OPENSHIFT_VERSION}/rhods-operator/
              mkdir -p ${OUTPUT_CATALOG_DIR}
              OUTPUT_CATALOG_PATH=${OUTPUT_CATALOG_DIR}/catalog.yaml

              #Invoke the stage promoter to patch the main catalog with release branch
              python3 utils/utils/stage-promoter/stage_promoter.py -op stage-catalog-patch -c ${CATALOG_YAML_PATH} -p ${PATCH_YAML_PATH} -r ${RELEASE_CATALOG_YAML_PATH} -o ${OUTPUT_CATALOG_PATH} -v ${RHOAI_VERSION}
          done < <(yq eval '.config.supported-ocp-versions.build[].name' $BUILD_CONFIG_PATH)

          #Copy the build-args-map
          cp ${BRANCH}/catalog/catalog_build_args.map main/catalog/${BRANCH}/tmp_args.map
          { echo -en 'RBC_RELEASE_BRANCH_COMMIT=${{ steps.validate-fbc-image.outputs.ref }}\n'; cat main/catalog/${BRANCH}/tmp_args.map; } > main/catalog/${BRANCH}/catalog_build_args.map
          rm -rf main/catalog/${BRANCH}/tmp_args.map
          if [[ ${{ github.event.inputs.force_build }} == 'true' ]]; then echo $(date +'%d-%m-%Y %H:%M:%S:%3N') > "main/builds/force-trigger-${BRANCH}.txt"; fi
          git -C main/catalog/${BRANCH} status
          GIT_STATUS=$(git -C main/catalog/${BRANCH} status)
          CATALOGS_CHANGED=YES
          if [[ $GIT_STATUS == *"nothing to commit"* ]]; then CATALOGS_CHANGED=NO; fi
          echo "CATALOGS_CHANGED=${CATALOGS_CHANGED}" >> $GITHUB_OUTPUT

      - name: Validate Catalogs
        id: validate-catalogs
        env:
          BRANCH: ${{ github.event.inputs.release_branch }}
        run: |
          cd ${{ steps.init.outputs.work_dir }}

          #Declare basic variables
          BUILD_CONFIG_PATH=${BRANCH}/config/build-config.yaml
          SHIPPED_RHOAI_VERSIONS_PATH=main/pcc/shipped_rhoai_versions.txt
          CATALOG_FOLDER_PATH=main/catalog/${BRANCH}

          #Validate Catalogs
          python3 utils/utils/validators/catalog_validator.py -op validate-catalogs --build-config-path ${BUILD_CONFIG_PATH} --catalog-folder-path ${CATALOG_FOLDER_PATH} --shipped-rhoai-versions-path ${SHIPPED_RHOAI_VERSIONS_PATH}

      - name: Pull latest
        if: ${{ steps.push-to-stage.outputs.CATALOGS_CHANGED == 'YES' }}
        id: pull-latest
        run: |
          cd ${{ steps.init.outputs.work_dir }}/main
          git pull --no-edit origin main



      - name: Commit and push the changes to main branch
        if: ${{ steps.push-to-stage.outputs.CATALOGS_CHANGED == 'YES' }}
        uses: dchourasia/push@master
        with:
          github_token: ${{ secrets.RBC_TOKEN }}
          branch: main
          message: "Patching the stage catalog with ${{ github.event.inputs.release_branch }} ${{ github.event.inputs.commit }}"
          repository: ${{ env.GITHUB_ORG }}/RHOAI-Build-Config
          directory: ${{ steps.init.outputs.work_dir }}/main
          author_name: Openshift-AI DevOps
          author_email: openshift-ai-devops@redhat.com
      - name: Monitor FBC stage builds
        if: ${{ steps.push-to-stage.outputs.CATALOGS_CHANGED == 'YES' }}
        id: monitor-fbc-builds
        env:
          BRANCH: ${{ github.event.inputs.release_branch }}
          RHOAI_VERSION: ${{ github.event.inputs.rhoai_version }}
          RHOAI_QUAY_API_TOKEN: ${{ secrets.QUAY_DEVOPS_APPLICATION_TOKEN }}
        run: |
          cd ${{ steps.init.outputs.work_dir }}
          LATEST_RBC_MAIN_COMMIT=$(git -C main log -1 | grep ^commit | cut -d " " -f 2)
          GIT_COMMIT=${LATEST_RBC_MAIN_COMMIT}
          BUILD_CONFIG_PATH=latest_rbc_release/config/build-config.yaml
          NUMERIC_RHOAI_VERSION=${BRANCH/rhoai-/}
          NUMERIC_RHOAI_VERSION=${NUMERIC_RHOAI_VERSION/./}
          CURRENT_ITERATION=0
          RERUN_NEEDED=false
          sleep 45
          declare -a FBC_STAGE_BUILD_PIPELINES=()
          declare -a MISSING_PIPELINES=()


          while IFS= read -r ocp_version;
          do
              #Declare FBC processing variables
              OPENSHIFT_VERSION=$ocp_version
              NUMERIC_OCP_VERSION=${OPENSHIFT_VERSION/v4./4}
              FBC_STAGE_BUILD_PIPELINE_PREFIX=rhoai-fbc-fragment-rhoai-${NUMERIC_RHOAI_VERSION}-ocp-${NUMERIC_OCP_VERSION}-on-push-
              FBC_STAGE_BUILD_PIPELINE_NAME=$(oc get pr -o json $(oc get pr -o=jsonpath="{.items[?(@.metadata.annotations.build\.appstudio\.redhat\.com/commit_sha==\"${LATEST_RBC_MAIN_COMMIT}\")].metadata.name}")  | FBC_STAGE_BUILD_PIPELINE_PREFIX="${FBC_STAGE_BUILD_PIPELINE_PREFIX}" jq -r "[.items | sort_by(.metadata.creationTimestamp) | reverse | .[] | select(.metadata.name | test(\"${FBC_STAGE_BUILD_PIPELINE_PREFIX}\")).metadata.name][0]")
              echo "OPENSHIFT_VERSION=$OPENSHIFT_VERSION"
              echo "FBC_STAGE_BUILD_PIPELINE_NAME=$FBC_STAGE_BUILD_PIPELINE_NAME"

              if [[ -n $FBC_STAGE_BUILD_PIPELINE_NAME ]]
              then
                FBC_STAGE_BUILD_PIPELINES+=($FBC_STAGE_BUILD_PIPELINE_NAME)
                PR_YAML_PATH="artifacts/fbc-build/${FBC_STAGE_BUILD_PIPELINE_NAME}.yaml"
                SECRET_YAML_PATH="artifacts/fbc-build/${FBC_STAGE_BUILD_PIPELINE_NAME}-secret.yaml"
                oc get pr $FBC_STAGE_BUILD_PIPELINE_NAME -o yaml > ${PR_YAML_PATH}
                secret_name=$(yq eval '.metadata.annotations["pipelinesascode.tekton.dev/git-auth-secret"]' ${PR_YAML_PATH})
                oc get secret ${secret_name} -o yaml > ${SECRET_YAML_PATH}
              else
                MISSING_PIPELINES+=($OPENSHIFT_VERSION)
              fi
          done < <(yq eval '.config.supported-ocp-versions.build[].name' $BUILD_CONFIG_PATH)


          if [[ ${#MISSING_PIPELINES[@]} -gt 0 ]]
          then
                echo "FBC stage build pipeline not started for following OCP versions: ${MISSING_PIPELINES[@]}"
                echo "Exiting.."
                exit 1
          fi
          PIPELINERUNS="${FBC_STAGE_BUILD_PIPELINES[@]}"
          FAILED_PIPELINES_INFO_PATH="artifacts/fbc-build/failed_build_pipelines.yaml"
          RHOAI_QUAY_API_TOKEN=${RHOAI_QUAY_API_TOKEN} python3 -u utils/utils/stage-promoter/stage_promoter.py -op monitor-fbc-pipelines -o utils/fbc_images.json -v ${BRANCH} --timeout 60 -b ${BUILD_CONFIG_PATH} --git-commit ${GIT_COMMIT} --pipelineruns "${PIPELINERUNS}" --pipeline-type build --failed-pipelines-info-path ${FAILED_PIPELINES_INFO_PATH}
          # echo "FAILED_PIPELINES_INFO_PATH=${FAILED_PIPELINES_INFO_PATH}" >> $GITHUB_OUTPUT

            if [[ -e ${FAILED_PIPELINES_INFO_PATH} ]]
            then
              echo "Following pipelines have failed, will attempt a rerun:"
              yq eval '.failed_pipelines[]' ${FAILED_PIPELINES_INFO_PATH}
              RERUN_NEEDED=true
              echo "FBC_BUILDS_RERUN_NEEDED=${RERUN_NEEDED}" >> $GITHUB_OUTPUT
              echo "FAILED_FBC_BUILD_PIPELINES_INFO_PATH=${FAILED_PIPELINES_INFO_PATH}" >> $GITHUB_OUTPUT
            fi


      - name: Retry and Monitor FBC stage builds
        if: ${{ steps.monitor-fbc-builds.outputs.FBC_BUILDS_RERUN_NEEDED == 'true' }}
        id: retry-fbc-builds
        env:
          BRANCH: ${{ github.event.inputs.release_branch }}
          RHOAI_VERSION: ${{ github.event.inputs.rhoai_version }}
          RHOAI_QUAY_API_TOKEN: ${{ secrets.QUAY_DEVOPS_APPLICATION_TOKEN }}
        run: |
          cd ${{ steps.init.outputs.work_dir }}
          LATEST_RBC_MAIN_COMMIT=$(git -C main log -1 | grep ^commit | cut -d " " -f 2)
          GIT_COMMIT=${LATEST_RBC_MAIN_COMMIT}
          BUILD_CONFIG_PATH=latest_rbc_release/config/build-config.yaml
          NUMERIC_RHOAI_VERSION=${BRANCH/rhoai-/}
          NUMERIC_RHOAI_VERSION=${NUMERIC_RHOAI_VERSION/./}
          CURRENT_ITERATION=0
          FAILED_PIPELINES_INFO_PATH=${{ steps.monitor-fbc-builds.outputs.FAILED_FBC_BUILD_PIPELINES_INFO_PATH }}

          prepare_pr_yaml()
          {
            YAML_PATH="$1"
            if [[ -e ${YAML_PATH} ]]
            then
              yq eval -i 'del(.metadata.annotations."pipelinesascode.tekton.dev/check-run-id")' ${YAML_PATH}
              yq eval -i 'del(.metadata.annotations."results.tekton.dev/record")' ${YAML_PATH}
              yq eval -i 'del(.metadata.annotations."results.tekton.dev/result")' ${YAML_PATH}
              yq eval -i 'del(.metadata.annotations."test.appstudio.openshift.io/create-snapshot-status")' ${YAML_PATH}
              yq eval -i 'del(.metadata.annotations."pipelinesascode.tekton.dev/log-url")' ${YAML_PATH}
              yq eval -i 'del(.metadata.annotations."pipelinesascode.tekton.dev/state")' ${YAML_PATH}
              yq eval -i 'del(.metadata.labels."tekton.dev/pipeline")' ${YAML_PATH}
              yq eval -i 'del(.metadata.labels."pipelinesascode.tekton.dev/check-run-id")' ${YAML_PATH}
              yq eval -i 'del(.metadata.creationTimestamp)' ${YAML_PATH}
              yq eval -i 'del(.metadata.finalizers)' ${YAML_PATH}
              yq eval -i 'del(.metadata.name)' ${YAML_PATH}
              yq eval -i 'del(.metadata.resourceVersion)' ${YAML_PATH}
              yq eval -i 'del(.metadata.uid)' ${YAML_PATH}
              yq eval -i 'del(.status)' ${YAML_PATH}
              # echo "=========================cat ${YAML_PATH}=========================="
              # cat ${YAML_PATH}
            else
              echo "Failed-pipelinerun yaml not found for FBC build at path ${YAML_PATH} while attempting the rerun"
              exit 1
            fi
          }

          prepare_secret_yaml()
          {
            YAML_PATH="$1"
            if [[ -e ${YAML_PATH} ]]
            then
              yq eval -i 'del(.metadata.creationTimestamp)' ${YAML_PATH}
              yq eval -i 'del(.metadata.ownerReferences)' ${YAML_PATH}
              yq eval -i 'del(.metadata.resourceVersion)' ${YAML_PATH}
              yq eval -i 'del(.metadata.uid)' ${YAML_PATH}
            else
              echo "Secret yaml not found for FBC build at path ${YAML_PATH} while attempting the rerun"
              exit 1
            fi
          }


          until [[ ${CURRENT_ITERATION} -eq ${MAX_RETRY_COUNT} ]]
          do
            CURRENT_ITERATION=$((CURRENT_ITERATION+1))
            if [[ -e ${FAILED_PIPELINES_INFO_PATH} ]]
            then

              echo "Following pipelines have failed, will attempt a rerun:"
              yq eval '.failed_pipelines[]' ${FAILED_PIPELINES_INFO_PATH}

              declare -a RETRIGGERED_FBC_STAGE_BUILD_PIPELINES=()

              FAILED_PIPELINES=$(yq eval '.failed_pipelines | join(" ")' ${FAILED_PIPELINES_INFO_PATH})
              IFS=' ' read -r -a FAILED_PIPELINES <<< "$FAILED_PIPELINES"
              export IFS=

              #retrigger all the failed pipelines
              for FAILED_PIPELINE in ${FAILED_PIPELINES[@]}
              do
                echo "starting to rerun the failed pipeline ${FAILED_PIPELINE}"
                # declare yaml paths
                PR_YAML_PATH="artifacts/fbc-build/${FAILED_PIPELINE}.yaml"
                SECRET_YAML_PATH="artifacts/fbc-build/${FAILED_PIPELINE}-secret.yaml"

                # cleanup and prepare the resource manifests
                prepare_pr_yaml "${PR_YAML_PATH}"
                prepare_secret_yaml "${SECRET_YAML_PATH}"

                # create the manifests
                oc apply -f ${SECRET_YAML_PATH}
                output=$(oc create -f ${PR_YAML_PATH} 2>&1)
                echo $output

                # get the new pipelinerun
                PIPELINE_PREFIX=${FAILED_PIPELINE:0:${#FAILED_PIPELINE}-6}
                if [[ "${output}" =~ ^pipelinerun.tekton.dev\/(${PIPELINE_PREFIX}-[0-9a-z]{5})[[:space:]]created$ ]]
                then
                  PIPELINERUN_NAME="${BASH_REMATCH[1]}"
                  echo "captured the new pipelinerun name as ${PIPELINERUN_NAME}"
                  RETRIGGERED_FBC_STAGE_BUILD_PIPELINES+=(${PIPELINERUN_NAME})
                else
                  echo "could not retrigger the pipeline ${FAILED_PIPELINE}, attempt failed with error - $output"
                  exit 1
                fi
              done
              # monitor the retriggered pipelines
              RETRIGGERED_PIPELINERUNS="${RETRIGGERED_FBC_STAGE_BUILD_PIPELINES[@]}"
              RHOAI_QUAY_API_TOKEN=${RHOAI_QUAY_API_TOKEN} python3 -u utils/utils/stage-promoter/stage_promoter.py -op monitor-fbc-pipelines -o utils/fbc_images.json -v ${BRANCH} --timeout 60 -b ${BUILD_CONFIG_PATH} --git-commit ${GIT_COMMIT} --pipelineruns "${RETRIGGERED_PIPELINERUNS}" --pipeline-type build --failed-pipelines-info-path ${FAILED_PIPELINES_INFO_PATH}
            fi
          done

          if [[ -e "utils/slack_failure_message.txt" ]]
          then
            echo "Exiting.."
            SLACK_FAILURE_MESSAGE=$(cat utils/slack_failure_message.txt)
            echo ${SLACK_FAILURE_MESSAGE}
            {
              echo "SLACK_FAILURE_MESSAGE<<EOF"
              echo -e "${SLACK_MESSAGE}"
              echo "EOF"
            } >> $GITHUB_ENV
            exit 1
          fi



      - name: Release FBC to Stage
        id: release-fbc-to-stage
        env:
          OC_TOKEN: ${{ secrets.RHOAI_KONFLUX_INTERNAL_SA_TOKEN }}
          API_SERVER: ${{ secrets.KONFLUX_INTERNAL_API_SERVER_URL }}
        run: |
          SLACK_FAILURE_MESSAGE=":alert:Push to stage failed during FBC release phase. \n Please check the logs at ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
            {
              echo "SLACK_FAILURE_MESSAGE<<EOF"
              echo -e "${SLACK_MESSAGE}"
              echo "EOF"
            } >> $GITHUB_ENV

          release_branch=${{ github.event.inputs.release_branch }}
          input_rhoai_version=${{ github.event.inputs.rhoai_version }}
          fbc_image_uri=${{ github.event.inputs.fbc_image_uri }}
          rhoai_version=${input_rhoai_version/v/}
          hyphenized_rhoai_version=${release_branch/rhoai-/}
          hyphenized_rhoai_version=v${hyphenized_rhoai_version/./-}
          component_application=rhoai-${hyphenized_rhoai_version}

          oc login --token="${OC_TOKEN}" --server=${API_SERVER}
          oc config set-context --current --namespace=rhoai-tenant
          oc get snapshots | wc -l
          cd ${{ steps.init.outputs.work_dir }}/infra/tools/rhoai-release-helper
          chmod +x *.sh
          sed -i "s/release_branch=rhoai-.*/release_branch=${release_branch}/g" release-fbc-to-stage.sh
          sed -i "s/^rhoai_version=.*/rhoai_version=${rhoai_version}/g" release-fbc-to-stage.sh
          sed -i "s/hyphenized_rhoai_version=v.*/hyphenized_rhoai_version=${hyphenized_rhoai_version}/g" release-fbc-to-stage.sh
          sed -i "s/hyphenized_rhoai_version=v.*/hyphenized_rhoai_version=${hyphenized_rhoai_version}/g" release-fbc-to-stage.sh
          epoch=$(date +%s)
          # Trigger the FBC release pipelines
          epoch=${epoch} image_uri="${fbc_image_uri}" execution_env=gha build_type="${{ github.event.inputs.build_type }}" ./release-fbc-to-stage.sh
          echo "epoch=${epoch}" >> ${GITHUB_OUTPUT}
          echo "component_application=${component_application}" >> ${GITHUB_OUTPUT}
          echo "snapshot_name=${component_application}-${epoch}" >> ${GITHUB_OUTPUT}



      - name: Monitor FBC stage release pipelines
        if: ${{ steps.push-to-stage.outputs.CATALOGS_CHANGED == 'YES' }}
        id: monitor-fbc-release-pipelines
        env:
          BRANCH: ${{ github.event.inputs.release_branch }}
          RHOAI_VERSION: ${{ github.event.inputs.rhoai_version }}
        run: |
          cd ${{ steps.init.outputs.work_dir }}
          LATEST_RBC_MAIN_COMMIT=$(git -C main log -1 | grep ^commit | cut -d " " -f 2)
          GIT_COMMIT=${LATEST_RBC_MAIN_COMMIT}
          BUILD_CONFIG_PATH=latest_rbc_release/config/build-config.yaml
          NUMERIC_RHOAI_VERSION=${BRANCH/rhoai-/}
          NUMERIC_RHOAI_VERSION=${NUMERIC_RHOAI_VERSION/./}
          fbc_application_prefix=rhoai-fbc-fragment-ocp
          epoch=${{ steps.release-fbc-to-stage.outputs.epoch }}
          FAILED_PIPELINES_INFO_PATH="artifacts/fbc-release/failed_build_pipelines.yaml"
          RERUN_NEEDED=false

          sleep 30
          declare -a FBC_STAGE_RELEASE_PIPELINES=()
          declare -a MISSING_PIPELINES=()


          while IFS= read -r ocp_version;
          do
              #Declare FBC processing variables
              OPENSHIFT_VERSION=$ocp_version
              fbc_application_suffix=${ocp_version/v4./4}
              fbc_application_name=${fbc_application_prefix}-${fbc_application_suffix}
              echo "${fbc_application_name}"
              oc get pipelinerun -n rhtap-releng-tenant -l appstudio.openshift.io/snapshot=${fbc_application_name}-${epoch}
              FBC_RELEASE_PIPELINE_NAME=$(oc get pr -o json -n rhtap-releng-tenant -l appstudio.openshift.io/snapshot=${fbc_application_name}-${epoch} | jq -r "[.items | sort_by(.metadata.creationTimestamp) | reverse | .[] | .metadata.name][0]")

              echo "OPENSHIFT_VERSION=$OPENSHIFT_VERSION"
              echo "FBC_RELEASE_PIPELINE_NAME=$FBC_RELEASE_PIPELINE_NAME"

              if [[ -n "$FBC_RELEASE_PIPELINE_NAME" ]]
              then
                FBC_STAGE_RELEASE_PIPELINES+=($FBC_RELEASE_PIPELINE_NAME)
                PR_YAML_PATH="artifacts/fbc-release/${FBC_RELEASE_PIPELINE_NAME}.yaml"
                oc get pr -n rhtap-releng-tenant $FBC_RELEASE_PIPELINE_NAME -o yaml > ${PR_YAML_PATH}
              else
                MISSING_PIPELINES+=($OPENSHIFT_VERSION)
              fi
          done < <(yq eval '.config.supported-ocp-versions.release[]' $BUILD_CONFIG_PATH)

          if [[ ${#MISSING_PIPELINES[@]} -gt 0 ]]
          then
                echo "FBC stage release pipeline not started for following OCP versions: ${MISSING_PIPELINES[@]}"
                echo "Exiting.."
                exit 1
          fi
          PIPELINERUNS="${FBC_STAGE_RELEASE_PIPELINES[@]}"
          python3 -u utils/utils/stage-promoter/stage_promoter.py -op monitor-fbc-pipelines -o utils/fbc_images.json -v ${BRANCH} --timeout 60 -b ${BUILD_CONFIG_PATH} --git-commit ${GIT_COMMIT} --pipelineruns "${PIPELINERUNS}" --pipeline-type release --failed-pipelines-info-path ${FAILED_PIPELINES_INFO_PATH}

            if [[ -e ${FAILED_PIPELINES_INFO_PATH} ]]
            then
              echo "Following pipelines have failed, will attempt a rerun:"
              yq eval '.failed_pipelines[]' ${FAILED_PIPELINES_INFO_PATH}
              RERUN_NEEDED=true
              echo "FBC_RELEASE_RERUN_NEEDED=${RERUN_NEEDED}" >> $GITHUB_OUTPUT
              echo "FAILED_FBC_RELEASE_PIPELINES_INFO_PATH=${FAILED_PIPELINES_INFO_PATH}" >> $GITHUB_OUTPUT
            fi

      - name: Retry and Monitor FBC stage release
        if: ${{ steps.monitor-fbc-release-pipelines.outputs.FBC_RELEASE_RERUN_NEEDED == 'true' }}
        id: retry-fbc-release
        env:
          OC_TOKEN: ${{ secrets.RHOAI_KONFLUX_INTERNAL_SA_TOKEN }}
          API_SERVER: ${{ secrets.KONFLUX_INTERNAL_API_SERVER_URL }}
          BRANCH: ${{ github.event.inputs.release_branch }}
          RHOAI_VERSION: ${{ github.event.inputs.rhoai_version }}
        run: |
          cd ${{ steps.init.outputs.work_dir }}
          release_artifacts_dir=$(ls infra/tools/rhoai-release-helper/ | grep stage-release-)
          release_fbc_dir=infra/tools/rhoai-release-helper/${release_artifacts_dir}/release-fbc
          CURRENT_ITERATION=0
          FAILED_PIPELINES_INFO_PATH=${{ steps.monitor-fbc-release-pipelines.outputs.FAILED_FBC_RELEASE_PIPELINES_INFO_PATH }}
          fbc_application_prefix=rhoai-fbc-fragment-ocp
          epoch=${{ steps.release-fbc-to-stage.outputs.epoch }}
          BUILD_CONFIG_PATH=latest_rbc_release/config/build-config.yaml
          LATEST_RBC_MAIN_COMMIT=$(git -C main log -1 | grep ^commit | cut -d " " -f 2)
          GIT_COMMIT=${LATEST_RBC_MAIN_COMMIT}

          until [[ ${CURRENT_ITERATION} -eq ${MAX_RETRY_COUNT} ]]
          do
            CURRENT_ITERATION=$((CURRENT_ITERATION+1))
            if [[ -e ${FAILED_PIPELINES_INFO_PATH} ]]
            then
              echo "Following pipelines have failed, will attempt a rerun:"
              yq eval '.failed_pipelines[]' ${FAILED_PIPELINES_INFO_PATH}

              declare -a RETRIGGERED_PIPELINES_OCP_VERSIONS=()
              declare -a RETRIGGERED_FBC_RELEASE_PIPELINES=()
              declare -a MISSING_PIPELINES=()

              FAILED_PIPELINES=$(yq eval '.failed_pipelines | join(" ")' ${FAILED_PIPELINES_INFO_PATH})
              IFS=' ' read -r -a FAILED_PIPELINES <<< "$FAILED_PIPELINES"
              export IFS=

              #retrigger all the failed pipelines
              for FAILED_PIPELINE in ${FAILED_PIPELINES[@]}
              do
                echo "starting to rerun the failed pipeline ${FAILED_PIPELINE}"
                PR_YAML_PATH="artifacts/fbc-release/${FAILED_PIPELINE}.yaml"
                FBC_APPLICATION_NAME=$(yq eval '.metadata.labels."appstudio.openshift.io/application"' ${PR_YAML_PATH})
                echo "FBC_APPLICATION_NAME=${FBC_APPLICATION_NAME}"


                # devise yaml paths
                hyphenized_rhoai_version=${BRANCH/rhoai-/}
                hyphenized_rhoai_version=v${hyphenized_rhoai_version/./-}
                RELEASE_YAML_PATH=${FBC_APPLICATION_NAME/-stage-/-rhoai-$hyphenized_rhoai_version-}
                RELEASE_YAML_PATH=${RELEASE_YAML_PATH/rhoai-fbc-fragment-/release-fbc-stage-}
                RELEASE_YAML_PATH=${release_fbc_dir}/$(ls ${release_fbc_dir} | grep ${RELEASE_YAML_PATH})
                echo "RELEASE_YAML_PATH=${RELEASE_YAML_PATH}"
                OCP_VERSION=$(yq eval '.metadata.labels."konflux-release-data/ocp-version"' ${RELEASE_YAML_PATH})
                echo "OCP_VERSION=${OCP_VERSION}"
                RETRIGGERED_PIPELINES_OCP_VERSIONS+=(${OCP_VERSION})

                #modify the release name to retrigger
                CURRENT_RELEASE=$(yq e '.metadata.name' ${RELEASE_YAML_PATH})
                echo "CURRENT_RELEASE=${CURRENT_RELEASE}"
                NEW_RELEASE_NAME="${CURRENT_RELEASE}-${CURRENT_ITERATION}"
                NEW_RELEASE_NAME="$NEW_RELEASE_NAME" yq eval -i '.metadata.name = env(NEW_RELEASE_NAME)' ${RELEASE_YAML_PATH}

                #start the release
                echo "Starting the new FBC release pipeline for ${OCP_VERSION}"
                oc apply -f ${RELEASE_YAML_PATH}
              done
              sleep 30

              # find the new pipelineruns
              for ocp_version in ${RETRIGGERED_PIPELINES_OCP_VERSIONS[@]}
              do
                  #Declare FBC processing variables
                  OPENSHIFT_VERSION=$ocp_version
                  fbc_application_suffix=${ocp_version/ocp-/}
                  fbc_application_name=${fbc_application_prefix}-${fbc_application_suffix}
                  echo "${fbc_application_name}"
                  oc get pipelinerun -n rhtap-releng-tenant -l appstudio.openshift.io/snapshot=${fbc_application_name}-${epoch}
                  FBC_RELEASE_PIPELINE_NAME=$(oc get pr -o json -n rhtap-releng-tenant -l appstudio.openshift.io/snapshot=${fbc_application_name}-${epoch} | jq -r "[.items | sort_by(.metadata.creationTimestamp) | reverse | .[] | .metadata.name][0]")

                  echo "OPENSHIFT_VERSION=$OPENSHIFT_VERSION"
                  echo "FBC_RELEASE_PIPELINE_NAME=$FBC_RELEASE_PIPELINE_NAME"

                  if [[ -n "$FBC_RELEASE_PIPELINE_NAME" ]]
                  then
                    RETRIGGERED_FBC_RELEASE_PIPELINES+=($FBC_RELEASE_PIPELINE_NAME)
                    PR_YAML_PATH="artifacts/fbc-release/${FBC_RELEASE_PIPELINE_NAME}.yaml"
                    oc get pr -n rhtap-releng-tenant $FBC_RELEASE_PIPELINE_NAME -o yaml > ${PR_YAML_PATH}
                  else
                    MISSING_PIPELINES+=($OPENSHIFT_VERSION)
                  fi
              done

              if [[ ${#MISSING_PIPELINES[@]} -gt 0 ]]
              then
                    echo "Failed to rerun FBC stage release pipeline for following OCP versions: ${MISSING_PIPELINES[@]}"
                    echo "Exiting.."
                    exit 1
              fi
              # monitor the FBC release pipelines
              PIPELINERUNS="${RETRIGGERED_FBC_RELEASE_PIPELINES[@]}"
              python3 -u utils/utils/stage-promoter/stage_promoter.py -op monitor-fbc-pipelines -o utils/fbc_images.json -v ${BRANCH} --timeout 60 -b ${BUILD_CONFIG_PATH} --git-commit ${GIT_COMMIT} --pipelineruns "${PIPELINERUNS}" --pipeline-type release --failed-pipelines-info-path ${FAILED_PIPELINES_INFO_PATH}
            fi
          done

          if [[ -e "utils/slack_failure_message.txt" ]]
          then
            echo "Exiting.."
            SLACK_FAILURE_MESSAGE=$(cat utils/slack_failure_message.txt)
            echo ${SLACK_FAILURE_MESSAGE}
            {
              echo "SLACK_FAILURE_MESSAGE<<EOF"
              echo -e "${SLACK_MESSAGE}"
              echo "EOF"
            } >> $GITHUB_ENV
            exit 1
          fi

          cat utils/slack_message.txt
          SLACK_MESSAGE=$(cat utils/slack_message.txt)
          {
            echo "SLACK_MESSAGE<<EOF"
            echo "EOF"
          } >> $GITHUB_OUTPUT

      - name: Send Success Notification
        if: success()
        uses: rtCamp/action-slack-notify@v2
        env:
          SLACK_MESSAGE: '${{ steps.retry-fbc-release.outputs.SLACK_MESSAGE }}'
          SLACK_WEBHOOK: ${{ secrets.SLACK_NOTIFICATIONS_WEBHOOK }}
          MSG_MINIMAL: true
          SLACK_COLOR: ${{ job.status }}

      - name: Send Failure Notification
        if: failure()
        uses: rtCamp/action-slack-notify@v2
        env:
          SLACK_MESSAGE: '${{ env.SLACK_FAILURE_MESSAGE }}'
          SLACK_WEBHOOK: ${{ secrets.SLACK_NOTIFICATIONS_WEBHOOK }}
          MSG_MINIMAL: true
          SLACK_COLOR: ${{ job.status }}
          SLACK_FOOTER: ''

      - name: Upload Release Artifacts
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: ${{ env.ARTIFACTS_NAME }}
          path: ${{ steps.init.outputs.work_dir }}/infra/tools/rhoai-release-helper/${{ env.ARTIFACTS_NAME }}


      - name: Cleanup workspace
        if: always()
        run: |
          rm -rf ${{ steps.init.outputs.work_dir }}
